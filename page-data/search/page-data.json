{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n大家平時都是怎麼決定該用哪個關鍵字（`var`、`let`、`const`）宣告變數的呢？受到 [ESlint 建議規範](https://eslint.org/docs/rules/no-var)的影響，我猜很多人跟我一樣，決定方式很簡單：會被再賦值（reassign）的就用 `let`，不會的就用 `const`。`var` 完全不在我們的選項，畢竟，`var` 有很多缺點，它的好處完全可以由 `let` 來代替，是吧？\n\n我承認我並沒有很認真探討過這個問題，只是照著 ESlint 規範走，直到在讀書會看了頗有名氣的 [You Don't Know JS Yet: Scope & Closures](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/README.md)（是的，它出第二版了），發現作者 Kyle Simpson 並不派斥 `var`，[甚至認為 `var` 的好處無法取代](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md#the-case-for-var)，這才讓我重新思考並質疑自己不使用 `var` 的理由。\n\n## `var` 很有用\n\nSimpson 認為，`var` 跟 `let` 都很有用（他沒有很喜歡 `const`，後面會說原因），前者為函數作用域（function scope），後者為區塊作用域（block scope），因此，當一個變數在整個函數中都會用到，那就該用 `var`，並宣告在**函數最外層**（top-level，也可以說是頂層）；反之，如果一個變數只會在函數中的某個區塊用到，那就該用 `let`，並宣告在**這個區塊內**，讓外層的作用域取用不到。\n\n比方說，假如我現在要寫一個能判斷使用者網頁捲動方向的函數，按照 ESlint 建議的寫法，會是這樣：\n\n```javascript\nfunction logScrollDirection() {\n  let beforeScrollY = window.pageYOffset;\n  \n  window.addEventListener('scroll', () => {\n    const currentScrollY = window.pageYOffset;\n    const delta = currentScrollY - beforeScrollY;\n\n    if (delta > 0) {\n      console.log('scroll down!');\n    } else {\n      console.log('scroll up!');\n    }\n\n    beforeScrollY = currentScrollY;\n  });\n}\n```\n\n但 Simpson 會建議這樣：\n\n```javascript\nfunction logScrollDirection() {\n  // 變成 `var` 了\n  var beforeScrollY = window.pageYOffset;\n  \n  window.addEventListener('scroll', () => {\n    // 變成 `var` 了\n    var currentScrollY = window.pageYOffset;\n    \n    // 多了大括號\n    // highlight-next-line\n    {\n      // 變成 `let` 了\n      let delta = currentScrollY - beforeScrollY;\n\n      if (delta > 0) {\n        console.log('scroll down!');\n      } else {\n        console.log('scroll up!');\n      }\n    // highlight-next-line\n    }\n\n    beforeScrollY = currentScrollY;\n  });\n}\n```\n\n你可能會想說，`let` 其實也是函數作用域，為什麼不乾脆把上面的 `var` 都改成 `let` 呢？\n\n理由有兩個：第一，就語義上來說，`var` 比 `let` 更適合扮演「這個變數是作用在整個函數中」的角色，畢竟在 `let` 還未出現前的 20 年，`var` 就一直都是如此。\n\n第二，如果你在任何地方都使用 `let `，那你可能會不好判斷這個 `let` 所宣告的變數是作用在整個函數中，還是只在某個區塊內。\n\n你可能還會注意到，在黃線處有個奇怪的大括號 `{..}`。這個括號能確保 `delta` 不被函數內的其它地方取用到，讓它成為名副其實的區塊變數。\n\n一般來說，我們在函數內創建區塊變數，是在遇到 `if..else` 或 `for` 迴圈的時候。但其實你可以不靠這些陳述語句（statement）來創建區塊變數，那就是直接用單獨的 `{..}` 大括號。\n\n這個大括號看來有點奇怪又累贅，但它事實上是讓 `var` 與 `let` 的搭配發揮最大效用的關鍵，而且它還體現了軟體工程的一個原則：最小暴露原則（The Principle of Least Exposure, POLE）。\n\n## 最小暴露原則\n\n最小暴露原則與[最小權限原則（The Principle of Least Privilege, POLP）](https://en.wikipedia.org/wiki/Principle_of_least_privilege)有關，但它關注的層次較低。就變數而言，它想最小化暴露的是其**作用域**。\n\n為什麼？想想一個極端的問題：為什麼我們不把所有變數都宣告在全局作用域（global scope）？命名衝突、被他人非預期或惡意修改、非意圖依賴導致重構困難（詳細說明可見[這裡](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch6.md#least-exposure)）——當我們把區域（local）變數非必要地暴露給程式其它部分使用時，這三個危險便會浮現，在日後絆你一跤。\n\n因此，我們應遵守最小暴露原則，**這意味著我們應盡可能地保持變數私有（private），也就是將變數宣告在盡可能深的嵌套作用域內**。\n\n說來容易，但這其實並不是一個很直覺的作法。我常需要在寫完函數的內容後，再回過頭來重新檢視程式碼，以找出哪些變數是函數中的區域變數（或甚至是區塊中的區域變數），再用 `{..}` 括起來。\n\n聽來有點麻煩，但這種作法不僅能避免上述危險，還意外地擁有兩個好處。\n\n第一個是當你不小心寫出一個肥大的函數，`{..}` 有助於你判斷哪些程式碼是彼此相關，從而讓你更容易理解整個函數在幹嘛。\n\n當然，我們應盡可能避免寫出這樣的函數，但即使寫出來了，當我們在重構（refactoring）時，也可以相對容易判斷出哪些區塊可以[提取成函數](https://refactoring.com/catalog/extractFunction.html)，以提升可讀性（readability）。\n\n同時，提取函數的過程也變得容易，因為你可以很快地判斷出變數的來源，知道現在要提取的區塊裡有哪些全局變數和區域變數，比如下面這段程式碼（請想像它是一個內容很長的函數）：\n\n```javascript\n/**\n * 此處範例借用自 Martin Fowler 的著作 Refactoring: Improving the Design of Existing Code (2nd Edition)\n * 第六章 Extract Fucntion 一節的程式碼\n */\nfunction printOwing(invoice) {\n  let outstanding = 0;\n  const today = new Date();\n  \n  printBanner();\n  \n  // ...\n  \n  for (const order of invoice.orders) {\n    outstanding += order.amount;\n  }\n\n  // highlight-next-line\n  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n  \n  // ...\n  \n  printDetails(invoice, outstanding);\n  \n  function printBanner() {\n    // ...\n  }\n  \n  function printDetails() {\n    // ...\n  }\n}\n```\n\n假設你想重構被黃線劃起來的區塊，把它提取成一個名為 `recordDueDate` 的函數，但由於你不知道 `today` 這個變數還有在這個函數中的哪個地方用到，因此你必須一行一行檢查，還必須進到內嵌函數去看有無使用到 `today`，相當麻煩。\n\n如果現在程式碼變成這樣：\n\n```javascript\nfunction printOwing(invoice) {\n  let outstanding = 0;\n  \n  printBanner();\n  \n  // ...\n  \n  for (const order of invoice.orders) {\n    outstanding += order.amount;\n  }\n\n  // highlight-start\n  {\n    let today = new Date();\n    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);\n  }\n  // highlight-end\n  \n  // ...\n  \n  printDetails(invoice, outstanding);\n  \n  function printBanner() {\n    // ...\n  }\n  \n  function printDetails() {\n    // ...\n  }\n}\n```\n\n清楚多了吧！現在你可以很篤定 `today` 絕對不會被這個區塊以外的地方用到，你可以放心又快速地把這兩行程式碼提取成 `recordDueDate` 函數了。\n\n## 取捨：評估 `var` 的缺點\n\n前面說了 `var` 的優點以及它該怎麼跟 `let` 搭配，這裡來談談 `var` 的缺點。\n\n先從建議禁用 `var` 的 ESlint 看起。為什麼不用 `var`？[ESlint 文件說](https://eslint.org/docs/rules/no-var)，因為在**區塊中**宣告 `var` 可能會意外地改變其外同名的變數。注意「區塊中」這三個字。沒錯，這點與前幾節所述原則相符，`var` 的確不應該宣告在區塊內，那是 `let` 發揮作用的地方。因此，前述原則已避免掉了這個缺點（Simpson 在[這篇](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md#the-case-for-var)講述了他覺得可以在區塊內宣告 `var` 的狀況，雖然我仍覺得宣告在外頭比較好，但值得看看）。\n\n再來，應該就是所謂重新宣告（redeclare）的問題。`let` 跟 `const` 將重新宣告的問題澈底消除。但，重新宣告真的是一個嚴重的問題嗎？更確切地問，這個缺點有辦法抵銷甚至壓過前述 `var` 的優點嗎？\n\n至少我自己是幾乎沒有碰過重新宣告的問題。即便你的函數都寫得很長，但當你很有意識地在區分變數的作用域範圍時，要出錯的機率可說是微乎其微。如果你真的很擔心程式壞掉，那你可以將所有用 `var` 宣告的變數都寫在最上面，總不會在這短短幾行中也有同名的問題吧？\n\n```javascript\nfunction doBigThing() {\n  var first = 'watch movies';\n  var second = 'shopping';\n  var third = 'sleep';\n  var first = ''; // <-- 哦哦抓到了，太明顯了吧！\n\n  // ..\n}\n```\n\n同樣地，重新賦值的問題也是如此。想想看，你會在什麼情況下，不小心將一個不該被重新賦值的變數重新賦值？這種情況多嗎？而且，即便你真的不小心犯錯了，會很難察覺嗎？會很難追蹤嗎？會很難改回來嗎？\n\n我認為這兩個缺點並不足以說服我放棄前面所說的宣告方法。而且相對地，這兩個缺點也給予開發者更大的彈性，只要你謹慎使用（同樣地在[這篇](Simpson)，Simpson 簡單示範了重新宣告作為一種註解的功用，雖然我不怎麼喜歡）。\n\n## 什麼時候該用 `const`？\n\n你可能會發現，在上面範例中，即使我是在區塊內宣告不會再被賦值的變數，我也是用 `let`。為什麼不用 `const`？這樣語義上不是更清晰嗎？\n\n好吧，其實我也是傾向用 `const`，但因為我介紹的是 Simpson 的論點，所以在宣告變數的寫法上就把他對 `const` 的意見也一併納入。\n\nSimpson 認為，`const` 是一個有點讓人困惑的關鍵字：你不是說這個變數是常數（constant）嗎？那為什麼它又可以被修改（mutate）呢？這個誤解的確常在 JS 新手身上發生（至少我在公司面試前端時是如此）。\n\n那該在什麼時候用 `const` 呢？只有當你宣告的變數已經是個不可變（immutable）的值（即基本型別值，詳情可見[這篇](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch6.md/#primitive-immutability)），而且它在語義上顯然是個常數時，才會用 `const`：\n\n```javascript\nconst POSTS_PAGE_SIZE = 3; // 每次要從資料庫取得的文章數量\nconst DEGREE_TO_PI = Math.PI / 180;\nconst DEFAULT_THEME = 'dark';\n\n// 其內容之後能被修改，不建議用 `const`\nconst SHARE_LINK_NAMES = ['fb', 'line'];\n```\n\n那重新賦值的問題呢？如同上一節所說，這個錯誤很難出現，即使出現也很好察覺並修復。而且當你會用 `{..}` 把區塊變數包起來，這個代碼塊通常不會太長，在這短短的十幾行中要出錯實在是不太可能。\n\n以上是 Simpson 的論點。對我來說，我認同重新賦值的問題並不大，但考量到非 JS 新手應該都能明白 `const` 的「不變」意指為何，我還是會繼續照一般規範走，只是要稍微忍受當看到一個由 `const` 宣告的變數，其內容在之後被修改時所引發的不適感。\n\n## 總結：一個原則，兩個問題\n\n當我在與別人協作時，我會採用由團隊討論出來的代碼規範，或直接引入主流規範（如 [Airbnb](https://github.com/airbnb/javascript) 或 [Standard](https://standardjs.com/)）。畢竟，我喜愛的宣告方式，它的好處還無法勝過降低團隊溝通成本所帶來的優勢。但我仍會在程式碼中盡可能地用 `{..}` 縮小變數的作用域。\n\n如果是我獨立開發的專案，當我碰到要宣告變數時，會問自己兩個問題。第一個：\n\n>  這是整個函數內都會使用到的變數嗎？\n\n是，就用 `var` 宣告在函數最上面；不是，遵循最小暴露原則，先用 `{..}` 括起，再問：\n\n> 這個變數會被重新賦值嗎？\n\n會，就用 `let`；不會，就用 `const`。\n\n整個決策過程並不複雜，至少我最近在開發瀏覽器擴充套件 [Notion+ 標記管理器](https://github.com/yeefun/notion-mark-manager)，是使用得挺愉快的，除了程式碼變得更易讀，修改起來也較容易。\n\n你是怎麼決定該用哪個關鍵字宣告變數的呢？你對我上面所說的一切，有什麼看法？歡迎留言給我！\n\n## 相關資料\n\n- [You Don't Know JS Yet: Scope & Closures (2nd Edition)](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/README.md)\n  - [Chapter 6: Limiting Scope Exposure](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch6.md)\n  - [Appendix A: Exploring Further - The Case for `var`](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md#the-case-for-var)\n","fields":{"slug":"/how-to-determine-the-variable-declaration-keyword/"},"frontmatter":{"date":"2020-10-10","description":"搭配 let，遵守最小暴露原則，var 其實很有用。","title":"no-var？決定變數宣告關鍵字的原則與問題","tags":["js","variable","scope"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n最近公司打 API 的方式換成 [GraphQL](https://graphql.org/)，這邊紀錄一下怎麼在 [Nuxt.js](https://nuxtjs.org/) 用 GraphQL 的 [fragments](https://graphql.org/learn/queries/#fragments) 特性，來達到重複使用程式碼查詢（query）的效果。\n\n## Fragments 是什麼\n\nfragments 是什麼？簡單來說，就是一個可重用的欄位（fields）片段，你可以在裡頭放好幾個查詢欄位，接著就可以拿這個片段放到不同的查詢物件中。\n\n最簡單的範例長這樣：\n\n```graphql\nquery posts {\n  rightPosts: allPosts {\n    ...postFields\n  }\n  \n  leftPosts: allPosts {\n    ...postFields\n  }\n}\n\nfragment postFields on Post {\n  id\n  title\n  heroImage {\n    title\n    urlMobileSized\n  }\n}\n```\n\n以 JavaScript 來類比，你可以想像 `postFields` 就是物件，而 `...postFields` 就像是把[物件展開（spread）](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)一樣，能將 `postFields` 內聯到 `rightPosts` 和 `leftPosts` 物件中，所以最後 `rightPosts` 實際上是長這樣：\n\n```graphql\nquery posts {\n  rightPosts: allPosts {\n    id\n    title\n    heroImage {\n      title\n      urlMobileSized\n    }\n  }\n}\n```\n\n## 情境闡述\n\n這是我在專案碰到的情況：我需要在網站的不同頁面去取得最新文章，它們的查詢欄位大致相同，但仍有些欄位不是每個查詢都需要的。\n\n最簡單的做法當然就是每個查詢都寫好自己的欄位。這個方法很快，但缺點就是重複，之後修改共同欄位需要一次改好幾個地方。\n\n另一個方法是使用指令（[directives](https://graphql.org/learn/queries/#directives)），藉由變數（[variables](https://graphql.org/learn/queries/#variables)）來動態地更改欄位，比如這樣：\n\n```graphql\nquery posts($shouldQueryTitle: Boolean!) {\n  allPosts {\n    id\n    title @include(if: $shouldQueryTitle)\n  }\n}\n```\n\n若 `shouldQueryTitle` 為 `true`，就會查詢 `title` 這個欄位，反之則不會。這個方法可行，但若需要客製化的欄位不少，實作起來會相當麻煩。\n\nfragments 能怎麼解決這個問題呢？很簡單，看共用欄位有哪些，把它們抽取成 fragment，再用 `...` 內聯。\n\n這個方法還有一個好處，就是它能**內聯嵌套查詢**，而非在第一層就整個覆蓋。比方說，下面這塊程式碼，`allPosts` 有兩個 `heroImage` 欄位，但裡頭查詢的欄位並不同：\n\n```graphql\nquery posts {\n  allPosts {\n    ...postFields\n    // highlight-next-line\n    heroImage {\n      urlTabletSized\n    }\n  }\n}\n\nfragment postFields on Post {\n  id\n  title\n  // highlight-next-line\n  heroImage {\n    title\n    urlMobileSized\n  }\n}\n```\n\n最後，`heroImage` 實際上是長這樣：\n\n```graphql\nheroImage {\n  title\n  urlMobileSized\n  urlTabletSized\n}\n```\n\n這可以讓我們在享受共用欄位的同時，還能客製化出不同的查詢內容。很方便吧！\n\n## 在多個檔案間共用 Fragments\n\n如果你是在 Nuxt 中使用 GraphQL，可以參考 [@nuxtjs/apollo](https://github.com/nuxt-community/apollo-module) 這個套件，它裡頭包著 [vue-apollo](https://github.com/vuejs/vue-apollo)。\n\n要創建一個查詢，可以[利用 `gql` 標籤直接寫在 `apollo` 物件裡](https://apollo.vuejs.org/guide/apollo/queries.html#simple-query)，也可以[另開一個 `.graphql` 或 `.gql` 檔](https://github.com/apollographql/graphql-tag#importing-graphql-files)。我偏好後者，因為比較好管理。\n\n回到 fragments。若是用檔案管理的方法，fragments 一般來說會放在使用它的檔案中。但如果我要在多個檔案間共用一個 fragment，那該怎麼做？\n\n具體情境是這樣的：我有好幾個不同的查詢物件，它們都會去查詢 `heroImage` 和 `ogImage`，而這兩個欄位也都是物件，會去查詢 tiny、mobile、tablet、desktop、original 這五種尺寸的圖片。每次查詢都要寫這 5 * 2 個欄位，實在是有點麻煩——有沒有辦法把它們抽取成一個 fragment 呢？\n\n在單一檔案中很簡單，就直接放在下面：\n\n```graphql\nquery latestPosts {\n  latestPosts: allPosts {\n    id\n    title\n    heroImage {\n      ...urls\n    }\n    ogImage {\n      ...urls\n    }\n  }\n}\n\nfragment urls on Image {\n  urlTinySized\n  urlMobileSized\n  urlTabletSized\n  urlDesktopSized\n  urlOriginal\n}\n```\n\n但若要在多個檔案間共用，可以把這個 fragment 移入一個獨立的檔案。假設檔案結構長這樣：\n\n```\napollo\n├─fragments\n   └─image-urls.gql <-- `urls` fragment is here!\n└─queries\n   ├─editor-choices.gql\n   ├─collaborations.gql\n   └─posts.gql\n```\n\n要怎麼把 `image-urls.gql` 導入到查詢檔案中使用呢？你可能會想說直接 `import`，但電腦會噴錯，因為 `import` 是 JS 語法，GraphQL 無法辨識。\n\n那該怎麼辦？經過我一番搜索，其實你可以這麼做：\n\n```graphql\n# highlight-next-line\n#import '../fragments/image-urls.gql'\n\nquery latestPosts {\n  latestPosts: allPosts {\n    id\n    title\n    heroImage {\n      ...urls\n    }\n    ogImage {\n      ...urls\n    }\n  }\n}\n```\n\n只要在 `import` 前加上 `#` 變成註解，就能成功把 fragments 導進來囉（我猜這應該是 [graphql-loader](https://github.com/creditkarma/graphql-loader) 的功勞，但詳細怎麼做的就不清楚了）。\n","fields":{"slug":"/how-to-use-graphql-fragments-in-nuxt/"},"frontmatter":{"date":"2020-10-01","description":"GraphQL fragments 是什麼？要怎麼在 Nuxt.js 不同檔案間共用？","title":"在 Nuxt.js 共用 GraphQL Fragments","tags":["nuxt","graphql","fragments"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n向假新聞宣戰早已不是什麼新鮮事了。獨立檢證、協力查核、智能辨識⋯⋯無論手段新穎或傳統，在假訊息竄增的速度面前，似乎都顯得蒼白無力，一不小心還會惹禍上身。這不禁讓人想問：還有什麼辦法？難道真理終究戰不勝謊言？人類還有救嗎？\n\n如果你已經對於當今所有防堵假訊息的手法都感到失望，準備當個極端的懷疑論者（這也不失為一個辦法），那你也許可以稍停一下，看看我底下將要介紹的計畫，也許它能帶給你一絲希望。\n\n去年 7 月，媒體界龍頭紐約時報（The New York Times，以下簡稱紐時）發起[「新聞溯源計畫」（The News Provenance Project）](https://www.newsprovenanceproject.com/)，期待透過區塊鏈技術揭露新聞更動源流，來讓大眾更好地區辨訊息真假或好壞。其矛頭第一個對準的就是假照片。\n\n**為什麼是假照片？區塊鏈在這整個計畫中的作用是什麼？「揭露新聞更動源流」是什麼意思？它能怎樣幫助我們辨別資訊？要達成這個目標，需要完成哪些事？**以下將一一回答。\n\n## 假照片破壞力強\n\n為什麼選擇假照片？理由似乎很直觀：照片比文字更容易傳播，且具有更高的可信度，因此破壞力也就愈強。據[美國獨立智庫研究](https://www.niemanlab.org/2020/01/heres-how-the-new-york-times-tested-blockchain-to-help-you-identify-faked-photos-on-your-timeline/)顯示，相較於其它形式的假訊息，美國人民對於大眾辨識假圖片或影片的信心和責任都更少。換言之，他們既覺得**大眾沒有能力辨識，也沒有義務辨識**。\n\n低落的防衛意識，使得假照片有大行其道的空間。隨著[「深假」（deepfake）技術的進步](https://opinion.cw.com.tw/blog/profile/51/article/8316)，製造出高水準視覺效果的成本愈來愈低。如何在資訊生態系統崩壞之前，從結構上防制假照片的危害，顯然是當務之急。\n\n## 區塊鏈如何溯源\n\n從結構上防制？紐時究竟想怎麼做？最初的想法，是為照片加上一些**元數據（metadata）及編輯紀錄**。前者如拍攝時間、地點、發布者等；後者則可想像有一條時間軸，上面記錄著誰在何時取用、發布，並做了哪些更動。\n\n舉例來說，假設阿帆今天在巴西拍到一張火噬雨林的照片，公布到臉書，並寫下：「天啊，地球之肺在燃燒！貪婪的人類終自食惡果！」阿昱看到了，順手把它載入自己的電腦。四個月後，澳洲森林發生大火，阿昱上傳這張照片，文字卻改為：「極端氣候正在吞噬澳洲！人類何時才要醒悟！」\n\n此時悠遊於臉書河道的你，猝不及防地滑到這則貼文。怵目驚心的照片使你的手指停了下來，各種情緒頓時湧上心頭——擔憂、憤怒、恐懼、羞愧——「這麼嚴重的事情，大家應該要知道啊」，你一邊想著，一邊按下分享。\n\n「欸？這是什麼？」你看到浮在照片下方的訊息區塊，裡頭有一行被黃色標起的文字：「四個月前拍攝」。\n\n「四個月前？什麼鬼？這不是現在正在發生的事嗎？」你點開區塊，看見這張照片最初拍攝的時間、地點，以及發布者（阿帆）當時的貼文內容。\n\n「殺小，該不會這是假照片吧？」你愈想愈不對勁，決定先將剛才分享貼文的隱私權限設為「只限本人」，並上網搜尋「澳洲大火」。最終你也許會發現：澳洲是真的有發生大火，但那張照片也是錯的。你不願做假訊息的幫兇，於是刪了貼文。\n\n![去年 8 月亞馬遜森林大火，便有許多錯誤照片在網路上瘋傳，連法國總統馬克宏都搞錯：他所分享的照片至少攝於 16 年前。圖擷自[馬克宏推特](https://twitter.com/EmmanuelMacron/status/1164617008962527232?s=20)](macron-twitter.png)\n\n謝天謝地！一場錯誤內容被轉發上萬次的災難被阻止了。**它靠的不是事後通知，也非事前審查，而是在訊息產生（或發布）當下，便在某處烙下一條不可更改的紀錄。它不做判斷，只呈現每次編輯的事實，讓讀者根據這些紀錄，自行決定要多相信這則訊息。**\n\n「聽起來真是不錯，」你可能會問：「但我要怎麼知道這些紀錄沒有被惡意更改過？」這就是區塊鏈發揮作用的地方了。區塊鏈是一種記錄資料的技術，一旦資料「上鏈」，便**難以被竄改**；同時它也是**透明**的，任何更改都會被記錄，且可被看見。它能確保照片元數據和編輯紀錄的真實性。\n\n## 概念驗證\n\n一個看似簡單的概念，實作起來往往有許多複雜微妙之處。\n\n比方說，我們知道這個計畫要在照片旁邊附上一些資訊，但要放哪些資訊？更深入點問：**平常人們在社群媒體上是如何決定一張照片可不可信的？不同背景的人，在判斷資訊方面又有什麼差異？我們所設想的方案，是否真的能幫助民眾更好地辨識新聞品質？**\n\n為了回答上述關鍵問題，紐時找了 34 位政治傾向、媒體偏好各異的成年人進行深度訪談和原型測試，從中歸納出了幾個值得參考的洞見。\n\n首先，關於民眾在社群平台上如何接收、判斷新聞資訊，紐時從「對於貼文脈絡的意識程度」（只看最顯眼的照片和標題？還是也會看發文日期、來源或網友反應？）和「對於主流媒體的信任程度」這兩條軸線，將民眾分成四種類型（來看看你比較偏向哪一種類型吧）：\n\n1. **高意識、低信任——不信任媒體的懷疑者（Distrustful news skeptic）**：認為主流媒體都是有偏見的，並會試圖從一些線索去證明，很難與特定媒體建立信任關係。值得注意的是，這些人多半是質疑媒體的報導方式，而非事實細節。\n2. **高意識、高信任——充滿自信的數位訂戶（Confident digital news subscriber）**：悠游於網路世界，樂意辨識自己信任的媒體所提供的訊息真假。他們不想與時事脫節或遭到誤導。\n3. **低意識、低信任——討厭媒體的庶民（Media-jaded localist）**：覺得自己的聲音遭到主流媒體所排擠，毫不遲疑地接受非正式的激昂評論（hot takes）。他們希望新聞能夠既真實又接地氣。當自己信任的非正式來源提供錯誤訊息時，他們需要更清晰的線索才能判定。\n4. **低意識、高信任——傳統的數位移民（Late-adopter media traditionalist）**：相較於網路媒體的喧囂，他們更喜歡透過電視、報紙等舊媒體來接收資訊。這類人需要學習更多的判斷技巧及明確的提示，才有辦法自己區辨訊息是否可信。\n\n紐時認為，照片溯源計畫至少能讓信任媒體的人受益（即 2、4 類人）。接著，他們測試多種能表示照片來源的設計，發現：\n\n- 認證標章（如臉書或 Instagram 的藍勾勾）並不足以讓照片變得可信。\n- 關於標示術語，讀者喜愛「附有來源」（sourced）更勝於「已驗證」（verified）。這代表大眾不只想知道照片已被他人驗證，**也希望有可讓自己探索的資訊**。\n- 陳列同一個事件的多張照片，能使讀者相信事件確實發生了。\n- 強調為人熟知的照片元數據（如圖說、發布歷史），而非會造成混亂的術語（如加密、存儲於不可更動的資料庫）。\n- 展示監督與問責的機制，有助於提升讀者信心。\n- 只需清楚呈現照片的編輯歷史，避免使用可能會失準的詞彙，如「真實」、「假」，**因為只要出錯一次，讀者就不會再完全信任這套機制**。\n\n紐時將這些發現整合進一個模擬社群網站的原型，經過兩輪測試，確認了來源資訊確實有效，而且即使是質疑新聞立場的讀者，也沒有懷疑來源資訊的真實性。\n\n不過仍有要改善的地方，包括有許多人根本沒注意到錯誤訊息、讀者很難理解為什麼來源訊息與照片描述不符。最有趣的是，對於照片編輯的歷史紀錄，讀者並不怎麼感興趣；反之，他們想瞭解照片所描述事件的相關新聞。這引出了一個洞見：\n\n> 民眾上社群網站不是為了查核事實，而是為了娛樂和建立聯繫。他們之所以願意停下來考察更多資訊，不是因為他們想證明這張照片是錯的，而是因為他們被與照片相連的故事引起了興趣。\n\n紐時認知到，這種傾向雖造成民眾容易為網路圖片所騙，但他們也能利用這點，讓溯源的過程不只有驗證的功能，還可以幫助讀者對自己關心的事情形成更準確、細緻的認識。\n\n吸取以上教訓，最終紐時建出了這個[概念原型](https://poc.newsprovenanceproject.com/)：\n\n- 來源資訊區塊變大了，裡頭增加了一些可引人注意的細節（如照片拍攝距今已多久）。\n- 展開資訊區塊，你可以看見上面有一塊醒目的提示，它能喚起讀者對於假照片的警戒。\n- 區塊下方列出關於同一事件的其它照片與文章連結，供讀者進一步探索。\n\n![概念原型：展開前。圖擷自[新聞溯源概念原型網頁](https://poc.newsprovenanceproject.com/)](poc-1.png)\n\n![概念原型：照片概觀。圖擷自[新聞溯源概念原型網頁](https://poc.newsprovenanceproject.com/)](poc-2.png)\n\n![概念原型：照片歷史紀錄。圖擷自[新聞溯源概念原型網頁](https://poc.newsprovenanceproject.com/)](poc-3.png)\n\n大家可以自己點進[網頁](https://poc.newsprovenanceproject.com/)玩玩，看這樣的來源標示是否有助於你判斷貼文內容的真假或好壞。\n\n---\n\n這是個令人振奮的開始——但也只是開始。目前的原型僅僅是最末端的呈現，要達到預期中的效果，紐時需要跨界合作，**建立一套從拍攝到發布的體系**，且其運作流程還要好上手，以免排擠較小的新聞機構。這顯然是一項極為艱難的任務。\n\n「當前的工作是確保大家以一致的方式來紀錄元數據，並讓這些資料能被其它組織（如社群平台）負責任地使用。」紐時研發團隊執行長 Marc Lavallee 說。他們在[官網](https://www.newsprovenanceproject.com/whats-next)公開徵求三種合作夥伴——社群平台、新聞編輯室、事實查核組織——來一起把計畫推展到下一階段：執行。\n\n一個更好的網際網路會是什麼樣子？這是紐時對於這個大哉問的初步回答。即使它最終失敗了，整個設計過程——從問題定義、用戶研究、概念發想到原型測試——仍有許多值得我們深思和借鏡的地方。\n\n## 相關資料\n\n- [The News Provenance Project](https://www.newsprovenanceproject.com/)——新聞溯源計畫官網，裡頭將計畫目前的成果與潛力做了一個清楚且頗具啟發性的闡述，推薦你把它從頭到尾看完。\n- [Proof of Concept](https://poc.newsprovenanceproject.com/)——新聞溯源的概念原型，來玩看看吧！\n- [How Do People Decide Whether to Trust a Photo on Social Media?](https://open.nytimes.com/how-do-people-decide-whether-to-trust-a-photo-on-social-media-e0016b6080ae)——社群媒體上的讀者是怎麼判斷一張照片可不可信的？這是紐時訪談後的發現。\n- [What If Every News Photo on Social Media Showed Contextual Information?](https://open.nytimes.com/what-if-every-news-photo-on-social-media-showed-contextual-information-8936cf4e8c45)——紐時測試原型的過程。\n- [Can Publishers Use Metadata to Regain the Public’s Trust in Visual Journalism?](https://open.nytimes.com/can-publishers-use-metadata-to-regain-the-publics-trust-in-visual-journalism-ee32707c5662)——簡單描述了整個新聞溯源計畫及未來展望。\n- [Here’s how The New York Times tested blockchain to help you identify faked photos on your timeline](https://www.niemanlab.org/2020/01/heres-how-the-new-york-times-tested-blockchain-to-help-you-identify-faked-photos-on-your-timeline/)——尼曼新聞實驗室對這個計畫的報導。\n- [Introducing the News Provenance Project](https://open.nytimes.com/introducing-the-news-provenance-project-723dbaf07c44)——去年 7 月，紐時在 Medium 上介紹了這個計畫。\n","fields":{"slug":"/what-is-the-news-provenance-project/"},"frontmatter":{"date":"2020-02-04","description":"透過區塊鏈技術揭露新聞更動源流，來讓大眾更好地區辨訊息真假或好壞——紐約時報發起的「新聞溯源計畫」究竟想做什麼？","title":"區塊鏈溯源能否打擊假照片？紐約時報架了一個社群網站來驗證這件事","tags":["假訊息","區塊鏈","媒體"],"update":"2020-08-01"}}}]}},"pageContext":{}},"staticQueryHashes":["2326376460"]}