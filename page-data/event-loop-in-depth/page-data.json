{"componentChunkName":"component---src-templates-post-tsx","path":"/event-loop-in-depth/","result":{"data":{"markdownRemark":{"html":"<p>事件迴圈（Event Loop）是一個我以為我懂了，但直到最近才發現自己什麼都不懂的概念。</p>\n<p>會發現這件事，是因為我在研究 React Fiber 的過程中，獲知了一個能提升網頁性能的 API <code class=\"language-text\">requestIdleCallback</code>，它的回呼（callback）會在瀏覽器空閒（idle）時執行，其中一個時機點是幀尾。</p>\n<p>問題來了，什麼是「幀尾」？要回答這個問題，首先當然要知道什麼是「幀」（frame）？原本我以為，幀就<strong>等同於</strong>網頁畫面更新——每一幀，畫面就更新一次。但若是這樣，哪來的「尾」可以給 <code class=\"language-text\">requestIdleCallback</code> 執行？或許，一幀除了更新，還做了許多事？</p>\n<p>就這樣，我從想瞭解一幀究竟做了哪些事，不小心掉進事件迴圈的漩渦，糾纏了一個多禮拜才爬出來，又花了好幾天才煉成這篇文章。</p>\n<p>本文將從官方規範下手，看完它，你便能回答：</p>\n<ul>\n<li>事件迴圈的運作流程為何？</li>\n<li>「幀」是什麼？</li>\n<li><code class=\"language-text\">setTimeout</code>、<code class=\"language-text\">requestAnimationFrame</code>、<code class=\"language-text\">requestIdleCallback</code> 分別發生在事件迴圈的哪個階段？</li>\n<li>宏任務（macrotask）和微任務（microtask）是什麼？它們與事件迴圈的關係是什麼？</li>\n<li>每輪事件迴圈都會更新畫面嗎？</li>\n<li>JavaScript 是單執行緒（single threaded），但卻能發出 HTTP 請求而不阻塞（non-blocking），這是怎麼辦到的？</li>\n</ul>\n<h2 id=\"js-單執行緒卻不阻塞的祕密\" style=\"position:relative;\"><a href=\"#js-%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92%E5%8D%BB%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%9A%84%E7%A5%95%E5%AF%86\" aria-label=\"js 單執行緒卻不阻塞的祕密 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS 單執行緒卻不阻塞的祕密</h2>\n<p>在開始之前，先來看一張圖：</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c9fda2d01746574d4d0f2c9bd9204bf5/7a3d6/event-loop-in-browser.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 104.57627118644068%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAIAAADJt1n/AAAACXBIWXMAAAsSAAALEgHS3X78AAADrElEQVQ4y3VSW28bRRTOjwGEQEGoPPIMglcQoAJSCxUVUq+gqpFqaCoMtA3gECdO80ChuTg0tDR2HN8DjRMnEWnSeB3H1/ia2OusL7vr3fXuzszOsms7TkDq0dnR7Oh8853zzdejdgNjfRHreMOibrZzWN0wH+UTs7o+iPmDdrX29RwDK9qCcovq7Pvq/CnV8bHiPAvcF6DnAnacVh2nVPtJxf8lhuIzwfjJkOI4g7yXsPO06vwUaWDvF8h7UfFcRHOfoO0pfFjZBSsdJJLFrXE+aOJWzPzKELti4leH+FUzp+cwFzRBKt4d8IgZY9zgmhwnMLwMkH4iI6UBIdYvPsr/RY+iIAhYWayR+4nifjaXiTUYUgEM16ShAg+VVBQFok4ipds2hFIjPxpeNpTiRlUI1HbvxFa/ym1eE1miM9GzowcCSdgz8Yk+du28WHNLxUEx/7Vc0MBPuyoKQIhWIkQ+RGS3wqVQWSh3wAiKYnkMZozq2nnA+NDBz2r1hkoZREYHK1jvfDoy8dpo74nrvSf6e18deOlz95l251rbolwalYo3Zeo6qHvF8j2ZtABysMmEW+Pq6k0S9wyevp8Ctwcefzfw+HvDQh8HuJbaSIwmRslMfzpxGdLeetFXLbhrhVm6vtOQZRnKWtHMtvWW/9s7gZGRxSFLwGz8q78DxkgqpEeaJaNauSHXPSzppnJ/0nszAhvXSJuwCbFiJSbGgpbptcnJ4Lh1feLH5VsNmdXBAEi4Ory5c1sqfqMx10qBajFQKbg4JtlqW59tfOu3XzbGHoZn7m9NPSB+v7lkZCWmozYgf2DzBkxelWsO7sBVKzxsFKd5ZqcLjpDhP0L356Nz81G7PfLIHXOilhaaYKBZXUD0HKjaBIZoMjtcPSTzBAJVrNtftyJWcEMUANQCaaniw3duVehWaJ8ASVYBDG+HImGibVv9wRQAkNj1Rpu26239BhGiLNMk8uV/suRd198WuztFS3FGTrKQqHKRuqBtorScbchKl7nlBP0vVKo/d8n0isl5bmnfsJi6tpT5wJO57Iv1+aNnfanP/Omr/uiVhcRH3gwtoTbhMTDFvzweetEavRuh1vPU2h59JbjniZfWcwe/hstjIXJlt7icq5xbzFNNeBys9/CU4p+3xl6Yir5lS5705t5zp19/EH/Xlf7Ql3vbnnzTltQ277jSb8wm/sPcHoEWgXu34k1XHClqNkHZkpRzt2JP6Pu5JOVIVWwJ6lGCWshW4eHQ/wJu5D8QLdyZ5AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"事件迴圈在瀏覽器的角色。圖片原始來源已不可考\"\n        title=\"事件迴圈在瀏覽器的角色。圖片原始來源已不可考\"\n        src=\"/static/c9fda2d01746574d4d0f2c9bd9204bf5/fcda8/event-loop-in-browser.png\"\n        srcset=\"/static/c9fda2d01746574d4d0f2c9bd9204bf5/fcda8/event-loop-in-browser.png 590w,\n/static/c9fda2d01746574d4d0f2c9bd9204bf5/7a3d6/event-loop-in-browser.png 990w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>事件迴圈在瀏覽器的角色。圖片原始來源已不可考</p></figcaption>\n  </figure></p>\n<p>不要看太久，有個概念就好；等你讀完這篇文章，就能看懂這張圖了。</p>\n<p>首先要闡明，事件迴圈是與 JS 的運行（runtime）環境相關的機制，它與 JS（引擎）本身無關。常見的運行環境有瀏覽器、Node.js，每種運行環境可能都有自己實現事件迴圈的方式，而本文只探討瀏覽器的事件迴圈（Node.js 的事件迴圈也是一個重要的主題，等到有天我搞懂了再來寫）。</p>\n<p>為什麼需要事件迴圈？這與 JS 單執行緒的特性有關。單執行緒意味著 JS 一次只能執行一段程式碼，當 JS 在調用（invoke）一個函式時，沒有任何其它程式碼可以<strong>同時</strong>運行，除非這個函式結束或被中斷（suspended）（後者可用 <a href=\"https://javascript.info/generators\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">generator</a> 達成）。</p>\n<p>深入點說，JS 內部有一個呼叫堆疊（call stack），又稱為執行上下文堆疊（execution context stack），這個堆疊是用來追蹤程式所呼叫的函式。每當程式調用一個函式，這個函式所產生的執行上下文便會被壓入（push）堆疊；當這個函式執行完，便會被彈出（pop）。函式的執行順序遵循「後進先出」（LIFO, Last In First Out）的模式。</p>\n<p>單執行緒雖簡單易懂，但卻有一個明顯的問題：假如一個函式執行過久，便會卡住之後函式的執行。如果這些函式恰好是做與 UI rendering 相關的事，那畫面便會延遲更新，這對使用者體驗來說是致命的。</p>\n<p>現在讓我們來想一下，JS 有什麼操作是相當耗時的？無論你的答案是什麼，我都已經想好了（欸），那就是請求資料。在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AJAX</a> 大行其道的年代，大家都在用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">XMLHttpRequest</code>（XHR）</a> 請求來請求去。如果使用者網路速度慢，可能一次請求就要花費好幾秒，但為什麼使用者的畫面仍能正常渲染（render），而沒有絲毫延宕？</p>\n<p>因為 XHR 並非由 JS 本身，而是由它的運行環境（即瀏覽器）<strong>自身的</strong>執行緒來處理的，因此不會阻塞呼叫堆疊。由瀏覽器負責處理的函式還有計時器 <code class=\"language-text\">setTimeout</code>、與動畫緊密相關的 <code class=\"language-text\">requestAnimationFrame</code>、害我一腳踏入事件迴圈泥淖的 <code class=\"language-text\">requestIdleCallback</code>⋯⋯它們通通統稱為 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Web APIs</a>。</p>\n<p>以計時器來舉例，當 JS 引擎執行到 <code class=\"language-text\">setTimeout(func, 3000)</code>，瀏覽器便接手過計時的操作，等三秒一到，便將它的 <code class=\"language-text\">func</code> 回呼塞進呼叫堆疊，讓引擎執行。這可說是一種非同步（asynchronous）的機制。</p>\n<p>一個複雜的網頁，可能會有許多回呼要執行，現在讓我們來問：是誰不停挑出回呼並將回呼塞進呼叫堆疊的？</p>\n<p>那就是今天的主角：事件迴圈。</p>\n<h2 id=\"事件迴圈的基本概念\" style=\"position:relative;\"><a href=\"#%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\" aria-label=\"事件迴圈的基本概念 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>事件迴圈的基本概念</h2>\n<p>同樣，在進到事件迴圈的流程前，先來看一張統整圖：</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e53e7455f561eeb2a702370fc75b7865/0a151/event-loop-process.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 127.79661016949153%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAH3YhQXPQc2x//EABoQAQACAwEAAAAAAAAAAAAAAAEAIRARMQL/2gAIAQEAAQUCi0c1GsJuNeDmf//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CT//EAB4QAAMAAgEFAAAAAAAAAAAAAAABESExQSBhgaHB/9oACAEBAAE/Ib3JNPY2HwaGBuWi1qHIoqhiJcmnXjo//9oADAMBAAIAAwAAABCTzjD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAcEAEAAwADAQEAAAAAAAAAAAABABEhMUFREJH/2gAIAQEAAT8Qohsd4rqMxFhtsjqWadrIpsQdf2MILGntEdheDjyDyUpKHpjsmEXzPYTEpRVs+IJSWQAKon//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"事件迴圈的運作流程。圖片原始來源已不可考\"\n        title=\"事件迴圈的運作流程。圖片原始來源已不可考\"\n        src=\"/static/e53e7455f561eeb2a702370fc75b7865/1c72d/event-loop-process.jpg\"\n        srcset=\"/static/e53e7455f561eeb2a702370fc75b7865/1c72d/event-loop-process.jpg 590w,\n/static/e53e7455f561eeb2a702370fc75b7865/0a151/event-loop-process.jpg 866w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>事件迴圈的運作流程。圖片原始來源已不可考</p></figcaption>\n  </figure></p>\n<p>看得懂在幹嘛嗎？看不懂？沒關係，繼續看下去，一切都會豁然開朗。</p>\n<p>（喂！有人說看得懂啊！不要假裝沒聽到！喂、喂——）</p>\n<p>（消音）</p>\n<p>接下來，我們會跟著這份由 <a href=\"https://whatwg.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WHATWG（Web Hypertext Application Technology Working Group）</a> 社群（a.k.a. 瀏覽器大佬）編寫的 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HTML 規範文件</a>，來理解事件迴圈詳細的運作流程。</p>\n<p>（原文是英文，我會以自己覺得重要且能理解的方式翻，不會嚴格地一個字一個字翻。如果我覺得英文能比中文表達得更清楚，那我就會維持原文）</p>\n<p>為什麼需要事件迴圈？開宗明義，規範便說了：</p>\n<blockquote>\n<p>為了協調事件、使用者互動，腳本，渲染，網路活動（networking）等，<a href=\"https://tc39.es/ecma262/#sec-agents\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用者代理（user agents）</a>必須使用本節所描述的事件迴圈。每個代理都有一個相關聯且唯一的事件循環。</p>\n</blockquote>\n<p>接下來，規範根據不同代理對事件循環做了三種分類：window event loop、worker event loop、worklet event loop。第一個代理是我們最常碰到的 Window 物件；第二個代理告訴我們 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">service worker</a> 會有自己的事件循環；第三個代理我不知道是什麼，知道的人可以留言給我。</p>\n<p>讓我們往下滑：</p>\n<blockquote>\n<p>一個事件循環會有一到多個任務佇列（task queues）。</p>\n<p>每個任務（task）都來自特定的任務源（task source）。每個任務源都必須對應一個特定的任務佇列。</p>\n</blockquote>\n<p>這兩段話出現了三個專有名詞：任務、任務源、任務佇列。</p>\n<p>首先，<strong>任務就是宏任務</strong>，它可以幹的事情相當多，包括發布（dispatch）<a href=\"https://www.w3schools.com/jsref/obj_event.asp\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Event 物件</a>（想想當事件監聽器觸發時，回呼所拿到的第一個參數）、解析（parse）HTML、呼叫回呼、<a href=\"https://fetch.spec.whatwg.org/#concept-fetch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">獲取（fetch）</a>資源、響應（reacting）DOM 操作。</p>\n<p>任務源也很多，但大都被歸類為<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">以下四種</a>：</p>\n<blockquote>\n<ul>\n<li>DOM 操作：比如以非阻塞的方式將元素插入 document。</li>\n<li>使用者互動：比如鍵盤輸入或滑鼠點擊。</li>\n<li>網路活動。</li>\n<li>歷史紀錄尋訪（ history traversal）：比如呼叫 <code class=\"language-text\">history.back()</code> API。</li>\n</ul>\n</blockquote>\n<p>（一個期待有人幫我解答的疑問：該怎麼證明某個把元素插入 document 的方式是非阻塞的？）</p>\n<p>那任務佇列又是幹嘛的呢？它是拿來分類任務源用的；換言之，不同的任務源可能會被塞進同一個任務佇列。但為什麼要對任務源進一步分類？這個例子說明得很清楚：</p>\n<blockquote>\n<p>例如，使用者代理可以將任務佇列分為給滑鼠和鍵盤事件（即使用者互動任務源）用的，和給其它任務源用的。藉此，使用者代理可以在<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">事件循環的處理模型</a>的初始步驟中，給與使用者互動任務源關聯的任務佇列四分之三的優先處理權，以讓介面保持響應性，但又不會卡死其它任務佇列。</p>\n</blockquote>\n<p>換言之，說到任務的處理順序時，並沒有誰先觸發誰就先執行的道理，這一切都要看你的瀏覽器如何實作。</p>\n<p>最後再講一件事：</p>\n<blockquote>\n<p>微任務佇列（microtask queue）不是任務佇列。</p>\n<p>微任務是一種通俗的講法，指的是透過 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-microtask\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">queue a microtask</a> 演算法創建的任務。</p>\n</blockquote>\n<p>微任務雖是一種任務（它們具有相同的<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#concept-task\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">結構</a>），但它所形成的佇列與任務佇列不同，而這是因為它們在成為佇列時所使用的演算法不同。</p>\n<p>有了這些基本概念後，接下來，讓我們直接進到事件循環的重頭戲吧！</p>\n<h2 id=\"事件迴圈是怎麼運作的？\" style=\"position:relative;\"><a href=\"#%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88%E6%98%AF%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%E7%9A%84%EF%BC%9F\" aria-label=\"事件迴圈是怎麼運作的？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>事件迴圈是怎麼運作的？</h2>\n<p>在 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">8.1.6.3 處理模型（Processing model）</a>中，規範描述了事件迴圈的運作流程：</p>\n<blockquote>\n<p>只要事件循環存在，便必須一直運行以下步驟：</p>\n<ol>\n<li>挑出一個任務佇列，要怎麼挑<a href=\"https://infra.spec.whatwg.org/#implementation-defined\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">由使用者代理決定</a>。如果沒有任務佇列，那就直接跳到微任務步驟。</li>\n<li>將 oldestTask 設為該任務佇列中第一個任務，並移除。</li>\n<li>將<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#currently-running-task\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">當前正在運行的任務</a>設為 oldestTask。</li>\n<li>Let taskStartTime be the <a href=\"https://w3c.github.io/hr-time/#dfn-current-high-resolution-time\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">current high resolution time</a>.</li>\n<li>Perform oldestTask's <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#concept-task-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">steps</a>.</li>\n<li>將當前正在運行的任務設回 null。</li>\n</ol>\n</blockquote>\n<p>前六步都滿好理解的。</p>\n<p>1：「由使用者代理決定」符合我們前面所說的，使用者代理可自行決定要給哪個任務佇列較高的優先處理權。</p>\n<p>2：由於是任務<strong>佇列</strong>，資料操作當然是遵循先進先出（FIFO, First-In-First-Out）的原則。</p>\n<blockquote>\n<ol start=\"7\">\n<li>\n<p>微任務：<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">施行微任務檢查（Perform a microtask checkpoint）</a>。</p>\n<ol>\n<li>If the <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">event loop</a>'s <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#performing-a-microtask-checkpoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">performing a microtask checkpoint</a> is true, then return.</li>\n<li>Set the <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">event loop</a>'s <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#performing-a-microtask-checkpoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">performing a microtask checkpoint</a> to true.</li>\n<li>\n<p>只要微任務佇列不為空：</p>\n<ol>\n<li>將 oldestMicrotask 設為對微任務佇列<a href=\"https://infra.spec.whatwg.org/#queue-dequeue\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">出列（dequeue）</a>的結果。</li>\n<li>將當前正在運行的任務設為 oldestMicrotask。</li>\n<li>運行 oldestMicrotask。</li>\n<li>將當前正在運行的任務設回 null。</li>\n</ol>\n</li>\n<li>For each <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">environment settings object</a> whose <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#responsible-event-loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">responsible event loop</a> is this <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">event loop</a>, <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#notify-about-rejected-promises\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">notify about rejected promises</a> on that <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">environment settings object</a>.</li>\n<li><a href=\"https://w3c.github.io/IndexedDB/#cleanup-indexed-database-transactions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Cleanup Indexed Database transactions</a>.</li>\n<li>Perform <a href=\"https://tc39.es/ecma262/#sec-clear-kept-objects\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ClearKeptObjects</a>().</li>\n<li>Set the <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">event loop</a>'s <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#performing-a-microtask-checkpoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">performing a microtask checkpoint</a> to false.</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>7：開始處理微任務。首先檢查 performing a microtask checkpoint 這個旗幟（flag）。為什麼需要？<strong>因為微任務檢查並不只有在事件循環的這個環節才觸發</strong>，其它觸發時機比如調用回呼後；而為了避免在處理微任務佇列時又施行微任務檢查（這可能在 7.3.3 發生），因此需要一個旗幟來控制（<a href=\"#%E5%BE%AE%E4%BB%BB%E5%8B%99%E7%9A%84%E5%9F%B7%E8%A1%8C%E7%AD%96%E7%95%A5\">後面</a>會再詳細說明微任務的執行策略）。</p>\n<p>7.3：檢查微任務佇列是否為空，若不為空，便執行第一個微任務。重複這個過程，直到所有微任務都執行完畢。</p>\n<p>7.4-6：我看不懂在做什麼，知道在幹嘛的人可以留言跟我說。</p>\n<blockquote>\n<ol start=\"8\">\n<li>將 hasARenderingOpportunity 設為 false.</li>\n<li>將 now 設為 <a href=\"https://w3c.github.io/hr-time/#dfn-current-high-resolution-time\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">current high resolution time</a>. [<a href=\"https://html.spec.whatwg.org/multipage/references.html#refsHRT\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HRT</a>]</li>\n<li>\n<p>Report the <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#concept-task\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">task</a>'s duration by performing the following steps:</p>\n<ol>\n<li>Let top-level browsing contexts be an empty <a href=\"https://infra.spec.whatwg.org/#ordered-set\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">set</a>.</li>\n<li>For each <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">environment settings object</a> settings of oldestTask's <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#script-evaluation-environment-settings-object-set\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">script evaluation environment settings object set</a>, <a href=\"https://infra.spec.whatwg.org/#set-append\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">append</a> setting's <a href=\"https://html.spec.whatwg.org/multipage/browsers.html#top-level-browsing-context\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">top-level browsing context</a> to top-level browsing contexts.</li>\n<li><a href=\"https://w3c.github.io/longtasks/#report-long-tasks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Report long tasks</a>, passing in taskStartTime, now (the end time of the task), top-level browsing contexts, and oldestTask.</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>8：從字面上理解，hasARenderingOpportunity 便是「是否有渲染機會」，一開始是 false，它將跟等下第 10 步的更新畫面（Update the rendering）有關。</p>\n<p>9：這裡的 now 將成為 <code class=\"language-text\">requestAnimationFrame</code> 回呼的第一個參數。</p>\n<p>10：我看不太懂在幹嘛，但 10.3 回報的 long tasks 似乎會出現在 <a href=\"https://web.dev/long-tasks-devtools/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Chrome 開發者工具的 Performance 面板中</a>。</p>\n<blockquote>\n<ol start=\"11\">\n<li>\n<p>更新畫面：如果是 window event loop，則：</p>\n<ol>\n<li>\n<p>Let docs be all <code class=\"language-text\">Document</code> objects whose <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#relevant-agent\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">relevant agent</a>'s <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#concept-agent-event-loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">event loop</a> is this event loop, sorted arbitrarily except that the following conditions must be met:</p>\n<ul>\n<li>Any <code class=\"language-text\">Document</code> B whose <a href=\"https://html.spec.whatwg.org/multipage/browsers.html#concept-document-bc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">browsing context</a>'s <a href=\"https://html.spec.whatwg.org/multipage/browsers.html#bc-container-document\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">container document</a> is A must be listed after A in the list.</li>\n<li>If there are two documents A and B whose <a href=\"https://html.spec.whatwg.org/multipage/browsers.html#concept-document-bc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">browsing contexts</a> are both <a href=\"https://html.spec.whatwg.org/multipage/browsers.html#child-browsing-context\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">child browsing contexts</a> whose <a href=\"https://html.spec.whatwg.org/multipage/browsers.html#bc-container-document\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">container documents</a> are another <code class=\"language-text\">Document</code> C, then the order of A and B in the list must match the <a href=\"https://dom.spec.whatwg.org/#concept-shadow-including-tree-order\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">shadow-including tree order</a> of their respective <a href=\"https://html.spec.whatwg.org/multipage/browsers.html#browsing-context-container\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">browsing context containers</a> in C's <a href=\"https://dom.spec.whatwg.org/#concept-node-tree\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">node tree</a>.</li>\n</ul>\n<p>In the steps below that iterate over docs, each <code class=\"language-text\">Document</code> must be processed in the order it is found in the list.</p>\n</li>\n<li>渲染機會（Rendering opportunities）：移除<a href=\"https://html.spec.whatwg.org/multipage/browsers.html#concept-document-bc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">瀏覽上下文（browsing context）</a>沒有渲染機會的 docs。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>11：這一步做的事情相當多（上面只是一小部分），主要是處理跟畫面渲染相關的事。</p>\n<p>11.1：我沒有全部看懂，但大致上就是選出 <code class=\"language-text\">Document</code> 物件、將它們指定給 docs，並以一定的規則排序。</p>\n<p>11.2：你可能會疑惑：要怎麼決定有無渲染機會？</p>\n<blockquote>\n<p>如果使用者代理當前能夠將瀏覽上下文的內容呈現給使用者，那該瀏覽上下文就有渲染機會，這需考慮硬體刷新率的限制，和使用者代理出於性能考量的節流，也需考慮内容的可呈現性（presentable），即使它在視窗（viewport）外。</p>\n</blockquote>\n<p>規範似乎覺得這裡沒說清楚，於是又補上（跟上句很像的）一句：</p>\n<blockquote>\n<p>瀏覽上下文的渲染機會是基於硬體限制（如顯示刷新率（display refresh rates））和其它因素（如頁面性能或頁面是否在背景（background））來確定的。渲染機會通常會定期出現。</p>\n</blockquote>\n<p>好像還是沒說清楚，再給一個註解：</p>\n<blockquote>\n<p>本規範並沒規定任何特定的模式來選擇渲染機會。但舉例來說，若瀏覽器試圖實現 60Hz 的刷新率，那渲染機會最多每 1/60 秒要出現一次（約 16.7ms）。若瀏覽器發現某個瀏覽上下文無法維持這個速率，它可能會將渲染機會降到可持續的每秒 30 次，而不是偶爾掉幀。同樣，如果一個瀏覽上下文不可見，使用者代理可能會決定將該頁面降到每秒 4 次渲染機會，甚至更少。</p>\n</blockquote>\n<p>說了這麼多，我們大致上可以這麼總結：不是每輪事件循環都會更新畫面，其頻率高低，端看瀏覽器怎麼實作。</p>\n<blockquote>\n<ol start=\"11\">\n<li>\n<p>更新畫面：</p>\n<ol start=\"3\">\n<li>如果 docs 不為空，則將 hasARenderingOpportunity 設為 true。</li>\n<li>\n<p>不必要的渲染（Unnecessary rendering）：移除滿足以下條件的 docs：</p>\n<ul>\n<li>使用者代理認為更新  <code class=\"language-text\">Document</code> 的瀏覽上下文的畫面不會有明顯的（visible）效果。</li>\n<li><code class=\"language-text\">Document</code> 的 map of animation frame callbacks 為空。</li>\n</ul>\n</li>\n<li>移除使用者代理由於其它原因認為最好（preferrable）跳過更新畫面的 docs。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>11.3：hasARenderingOpportunity 在第 8 步曾出現過。</p>\n<p>11.4-5：與 11.2 做的事類似，再「兩」次篩選掉不需渲染的 docs。</p>\n<p>11.4：把篩選條件說得很清楚，值得注意的是，animation frame callback 就是放在 <code class=\"language-text\">requestAnimationFrame</code> 的回呼。</p>\n<p>11.5：有說等於沒說，其目的應是授與瀏覽器決定是否要渲染的權力。不過規範還是舉例了：</p>\n<blockquote>\n<p>比如為確保某些任務緊接著執行，只有微任務檢查交錯其間（而且沒有 animation frame callbacks 參與 ）。具體來說，使用者代理可能希望合併定時器回呼，中間沒有畫面更新。</p>\n</blockquote>\n<p>同時規範也說明了設立 11.2 和 11.4 的目的：</p>\n<blockquote>\n<p>被標註為「渲染機會」的步驟可防止使用者代理在<strong>無法向使用者呈現新内容時</strong>更新畫面。</p>\n<p>被標註為「不必要的渲染」的步驟可防止使用者代理在<strong>没有新内容可繪製時</strong>更新畫面。</p>\n</blockquote>\n<p>到這裡，如果 docs 還有<a href=\"https://html.spec.whatwg.org/multipage/browsers.html#fully-active\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">充分活躍（fully active）</a>的 <code class=\"language-text\">Document</code>，那就一一對它們：</p>\n<blockquote>\n<ol start=\"11\">\n<li>\n<p>更新畫面：</p>\n<ol start=\"6\">\n<li><a href=\"https://html.spec.whatwg.org/multipage/interaction.html#flush-autofocus-candidates\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">flush autofocus candidates</a></li>\n<li><a href=\"https://drafts.csswg.org/cssom-view/#run-the-resize-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">run the resize steps</a></li>\n<li><a href=\"https://drafts.csswg.org/cssom-view/#run-the-scroll-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">run the scroll steps</a></li>\n<li><a href=\"https://drafts.csswg.org/cssom-view/#evaluate-media-queries-and-report-changes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">evaluate media queries and report changes</a></li>\n<li><a href=\"https://drafts.csswg.org/web-animations/#update-animations-and-send-events\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">update animations and send events</a></li>\n<li><a href=\"https://fullscreen.spec.whatwg.org/#run-the-fullscreen-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">run the fullscreen steps</a></li>\n<li><a href=\"https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#run-the-animation-frame-callbacks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">run the animation frame callbacks</a></li>\n<li><a href=\"https://w3c.github.io/IntersectionObserver/#run-the-update-intersection-observations-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">run the update intersection observations steps</a></li>\n<li>Invoke the <a href=\"https://w3c.github.io/paint-timing/#mark-paint-timing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mark paint timing</a> algorithm</li>\n<li>更新該 <code class=\"language-text\">Document</code> 的畫面或使用者介面，及其瀏覽上下文以反映當前狀態。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>11.6-13：你可以看到很多熟悉的名字，比如事件類型 <code class=\"language-text\">resize</code> 和 <code class=\"language-text\">scroll</code>、與 RWD（Responsive Web Design）息息相關的 media queries、常被拿來做懶加載（lazy load）的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Intersection Observer</a>。</p>\n<p>11.12：執行 <code class=\"language-text\">requestAnimationFrame</code> 的回呼。</p>\n<p>11.14：不知道在幹嘛，但似乎跟網頁性能指標 <a href=\"https://web.dev/first-contentful-paint/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">FCP（First Contentful Paint）</a>有關。</p>\n<p>到這裡，事件循環的更新畫面結束，接下來：</p>\n<blockquote>\n<ol start=\"12\">\n<li>\n<p>如果滿足以下條件：</p>\n<ol>\n<li>事件循環是 window event loop；</li>\n<li>在任務佇列中沒有任何任務；</li>\n<li>微任務佇列為空；</li>\n<li>hasARenderingOpportunity 為 false；</li>\n</ol>\n<p>運行 <a href=\"https://w3c.github.io/requestidlecallback/#start-an-idle-period-algorithm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">start an idle period algorithm</a>。</p>\n</li>\n</ol>\n</blockquote>\n<p>12：若條件都滿足，<code class=\"language-text\">requestIdleCallback</code> 的回呼將在這步執行（終於找到你啦！我找你找得好苦啊！）。</p>\n<p>第 13 步是在講事件循環是 worker event loop 的情況，與本文主題無關，跳過。</p>\n<p>一輪事件迴圈到此運作完畢。現在再回去看本節開頭的統整圖，是不是很清楚了呢？</p>\n<p>還不清楚？沒關係，讓我們結合呼叫堆疊、Web APIs 和事件迴圈，來實際跑一遍流程吧！</p>\n<h2 id=\"從範例了解事件迴圈\" style=\"position:relative;\"><a href=\"#%E5%BE%9E%E7%AF%84%E4%BE%8B%E4%BA%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88\" aria-label=\"從範例了解事件迴圈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>從範例了解事件迴圈</h2>\n<p>先來看一個簡單的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onFulfill1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onFulfill2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'main'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">logSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">logSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'something'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>當程式執行，會發生什麼事？</p>\n<ol>\n<li>建立一個全局執行上下文（global execution stack），壓入呼叫堆疊。</li>\n<li>遇到 <code class=\"language-text\">setTimeout</code>，由 Web API 接管計時器的處理，時間一到便把 <code class=\"language-text\">onTimeout</code> 排入任務佇列。</li>\n<li>遇到 <code class=\"language-text\">Promise.then()</code>，將 <code class=\"language-text\">onFulfill1</code> 排入微任務佇列。</li>\n<li>在控制台（console）印出 <code class=\"language-text\">main</code>。</li>\n<li>調用 <code class=\"language-text\">logSomething</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">something</code>。</li>\n<li><code class=\"language-text\">logSomething</code> 執行完畢，彈出。</li>\n<li>程式執行完畢，全局執行上下文彈出。</li>\n<li>施行微任務檢查：微任務佇列不為空，出列。</li>\n<li>調用 <code class=\"language-text\">onFulfill1</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">promise1</code>。</li>\n<li><code class=\"language-text\">onFulfill1</code> 執行完畢，彈出。</li>\n<li>遇到 <code class=\"language-text\">Promise.then()</code>，將 <code class=\"language-text\">onFulfill2</code> 排入微任務佇列。</li>\n<li>微任務佇列不為空，出列。</li>\n<li>調用 <code class=\"language-text\">onFulfill2</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">promise2</code>。</li>\n<li><code class=\"language-text\">onFulfill2</code> 執行完畢，彈出。</li>\n<li>微任務佇列為空，微任務檢查完畢。</li>\n<li>呼叫堆疊為空，事件循環從任務佇列取出最舊的任務。</li>\n<li>調用 <code class=\"language-text\">onTimeout</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">timeout</code>。</li>\n<li><code class=\"language-text\">onTimeout</code> 執行完畢，彈出。</li>\n</ol>\n<p>你可能會疑惑： 為什麼微任務是在程式執行完畢後便執行？微任務檢查不是應該在調用一個任務後（在此例即是 <code class=\"language-text\">onTimeout</code>）才觸發嗎？</p>\n<p>別忘記我提醒過你的：微任務檢查的觸發時機相當多。<a href=\"#%E5%BE%AE%E4%BB%BB%E5%8B%99%E7%9A%84%E5%9F%B7%E8%A1%8C%E7%AD%96%E7%95%A5\">下一節</a>我會詳述微任務的執行策略。</p>\n<p>再來看一個比較複雜的例子：</p>\n<p>HTML：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>btn<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>button<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Click me!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>JS：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> btn <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'btn'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nbtn<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token function\">onClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onIdle2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'idle2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onFulfill1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onAf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'raf'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onFulfill2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">onIdle1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'idle1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>當你點擊按鈕，控制台會印出什麼？</p>\n<p>答案不只一種，在不同瀏覽器或同一瀏覽器的不同時間，可能會出現不同結果。若只看最常出現的結果，Chrome 89.0.4389.90 是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">promise1\nraf\npromise2\ntimeout\nidle1\nidle2</code></pre></div>\n<p>Firefox 87.0 是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">promise1\ntimeout\nraf\npromise2\nidle1\nidle2</code></pre></div>\n<p>或是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">promise1\ntimeout\nidle1\nraf\npromise2\nidle2</code></pre></div>\n<p>但無論是哪種結果，都能被事件循環的處理模型解釋；換言之，差異並不來自規範失效，而來自規範賦予瀏覽器的彈性。</p>\n<p>讓我們一步步來：</p>\n<ol>\n<li>由 Web API 接管 <code class=\"language-text\">click</code> 事件的處理，將其回呼排入任務佇列。</li>\n<li>調用 <code class=\"language-text\">onClick</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>遇到 <code class=\"language-text\">setTimeout</code>，由 Web API 接管計時器的處理，時間一到便把 <code class=\"language-text\">onTimeout</code> 排入任務佇列。</li>\n<li>遇到 <code class=\"language-text\">Promise.then()</code>，將 <code class=\"language-text\">onFulfill1</code> 排入微任務佇列。</li>\n<li>遇到 <code class=\"language-text\">requestAnimationFrame</code>，將其回呼 <code class=\"language-text\">onAf</code> 放入 map of animation frame callbacks。</li>\n<li>遇到 <code class=\"language-text\">requestIdleCallback</code>，將其回呼 <code class=\"language-text\">onIdle1</code> 放入 list of idle request callbacks。</li>\n<li><code class=\"language-text\">onClick</code> 執行完畢，彈出。</li>\n<li>施行微任務檢查：微任務佇列不為空，出列。</li>\n<li>調用 <code class=\"language-text\">onFulfill1</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">promise1</code>。</li>\n<li><code class=\"language-text\">onFulfill1</code> 執行完畢，彈出。</li>\n</ol>\n<p>接下來，分歧產生了：究竟是會先執行計時器的回呼 <code class=\"language-text\">onTimeout</code>，還是 <code class=\"language-text\">requestAnimationFrame</code> 的回呼 <code class=\"language-text\">onAf</code>？端看此時 <code class=\"language-text\">onTimeout</code> 有沒有被排入任務佇列。你可能會說，<code class=\"language-text\">setTimeout</code> 的等待時間既是 <code class=\"language-text\">0</code>，其回呼應該就要被馬上排入任務佇列吧？</p>\n<p>不一定，因為事實上規範在<a href=\"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timer-initialisation-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">計時器初始化步驟</a>中有授與瀏覽器延長時間的權力：</p>\n<blockquote>\n<ol start=\"17\">\n<li>可選擇再等待一個由使用者代理決定的時間長度。</li>\n</ol>\n</blockquote>\n<p>目的是：</p>\n<blockquote>\n<p>為了最佳化（optimize）裝置的電力使用（power usage）。例如，一些處理器具有低電量模式，其中定時器的粒度（granularity）會降低。在這種平台上，使用者代理可減慢定時器，而非要求處理器使用更精確的模式、消耗較高的電力。</p>\n</blockquote>\n<p>雖然我不知道 Chrome 為何要在我這台 2017 年出廠的 MacBook Pro 13 上做這件事，但反正理由百百款，我們只要知道有這個可能性就好。</p>\n<p>所以，Chrome 的情況應該是：</p>\n<ol>\n<li>呼叫堆疊為空，由於無合格的任務佇列，且微任務佇列為空，事件循環進到更新畫面步驟。</li>\n<li>運行 animation frame callbacks。</li>\n<li>調用 <code class=\"language-text\">onAf</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">raf</code>。</li>\n<li>遇到 <code class=\"language-text\">Promise.then()</code>，將 <code class=\"language-text\">onFulfill2</code> 排入微任務佇列。</li>\n<li><code class=\"language-text\">onAf</code> 執行完畢，彈出。</li>\n<li>施行微任務檢查：微任務佇列不為空，出列。</li>\n<li>調用 <code class=\"language-text\">onFulfill2</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">promise2</code>。</li>\n<li><code class=\"language-text\">onFulfill2</code> 執行完畢，彈出。</li>\n<li>由於 hasARenderingOpportunity 為 true，或任務佇列中有任務，跳過 start an idle period algorithm。</li>\n<li>呼叫堆疊為空，事件循環從任務佇列取出最舊的任務。</li>\n<li>調用 <code class=\"language-text\">onTimeout</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">timeout</code>。</li>\n<li>遇到 <code class=\"language-text\">requestIdleCallback</code>，將其回呼 <code class=\"language-text\">onIdle2</code> 放入 list of idle request callbacks。</li>\n<li><code class=\"language-text\">onTimeout</code> 執行完畢，彈出。</li>\n<li>start an idle period algorithm，調用 <code class=\"language-text\">onIdle1</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">idle1</code>。</li>\n<li><code class=\"language-text\">onIdle1</code> 執行完畢，彈出。</li>\n<li>調用 <code class=\"language-text\">onIdle2</code>，將其函式執行上下文壓入呼叫堆疊。</li>\n<li>印出 <code class=\"language-text\">idle2</code>。</li>\n<li><code class=\"language-text\">onIdle2</code> 執行完畢，彈出。</li>\n</ol>\n<p>Firefox 的狀況呢，我有點累了（我相信你也累了），有空時可自行推導。</p>\n<p>我只講 Firefox 的第二種結果——<code class=\"language-text\">onIdle1</code> 怎麼會緊接在 <code class=\"language-text\">onTimeout</code> 之後執行？一個合理的猜測是：在這輪事件循環，用戶代理跳過了更新畫面，而且是在 Rendering opportunities 這步就把將被更新畫面的 <code class=\"language-text\">Document</code> 移除了，這樣 hasARenderingOpportunity 才不會被設為 true，<code class=\"language-text\">requestIdleCallback</code> 的回呼也才有辦法被執行。</p>\n<p>現在，你應該對事件循環的運作流程有很清楚的認識了，但本文還沒有要結束⋯⋯因為我還要講前面一直說會講的微任務的執行策略。</p>\n<h2 id=\"微任務的執行策略\" style=\"position:relative;\"><a href=\"#%E5%BE%AE%E4%BB%BB%E5%8B%99%E7%9A%84%E5%9F%B7%E8%A1%8C%E7%AD%96%E7%95%A5\" aria-label=\"微任務的執行策略 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>微任務的執行策略</h2>\n<p>微任務的觸發時機既簡單又複雜。先講複雜的：前面說過，執行微任務前會先施行微任務檢查，而微任務檢查的觸發時機可參考這張圖：</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f8f62e0a1f68feb6668da05dab93ecca/3d4b6/perform-a-microtask-checkpoint.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.94915254237287%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACSUlEQVQ4y1WU525aQRCFef+X4A9CdAOm2wYb04sNooVqTJGSIMVBoRdN/I20CJCOdvbevWfOzJzFsl6vZbvdyuFwUOz3e9ntdhofj0fFdQx4z3cGm81GVquVnE4nsWQyWclms+Lz+SQYDEosFpNkMql7r9crDodDwuGwOJ1OcbvdYrfbJZfLycfHh/T7fRkMBjIcDqXdbiuxRb5/z8/PYrVa5e7uTu7v75X45eVFOp2ONJtNXVutljQaDd1D9Pn5qaQQjkYjPaOEP/tfUqvV5PHxUSKRiCpDRSgUklQqpckgpwrOED89PelZ3qMOwovC1Z+tEkIQCAQUlEp5rDabTVwulxQKBVWHUkAMCWpvSv77a6UHUIAaMj88PEg0GpV0Oq1xPp+X+Xwu0+lUJpPJZb0GxEr4e/Bd8ntNhwEJfYTo7e1NKpWKlMtlTQYYBkqJeU78+vqqCfmGiVuW//ZSr9d1GH6/X8FkAb0kSbFYVKVUAIFZITE9pr9K2Gp8SbfX0Ww02/QSYlZagJrZbKaTNWDC4/FYcVPy6XTUBlMG/kMpvmMgHo/n4k8SmbYkEgkF51B5M5Th+0w63baUSqWLLVBFufQTlSQhAXuScBZn4L1er3drm8P+KN3uD20sSuLxuIKbYQhJwDtIUYqNeEbpxocXY8PMDSArRMaLlGNujkkAYSaT0SqwGn1EIbeFvRKu1xt9CGm1WlW7YA9jEayDemMTBDAIvkEdw8KjxEp4Pp91Sjwg4/X0gNmblXNMFEC2XC4Vi8VC/6n+AxnZ/06kkcdrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"規範中有引用到 perform a microtask checkpoint 關鍵字的段落。圖擷自 [WHATWG 規範文件](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)\"\n        title=\"規範中有引用到 perform a microtask checkpoint 關鍵字的段落。圖擷自 [WHATWG 規範文件](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)\"\n        src=\"/static/f8f62e0a1f68feb6668da05dab93ecca/fcda8/perform-a-microtask-checkpoint.png\"\n        srcset=\"/static/f8f62e0a1f68feb6668da05dab93ecca/fcda8/perform-a-microtask-checkpoint.png 590w,\n/static/f8f62e0a1f68feb6668da05dab93ecca/3d4b6/perform-a-microtask-checkpoint.png 712w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>規範中有引用到 perform a microtask checkpoint 關鍵字的段落。圖擷自 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WHATWG 規範文件</a></p></figcaption>\n  </figure></p>\n<p>點擊<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">這個連結</a>，再點擊 perform a microtask checkpoint 粗體字，你也可以看到引用這個關鍵字的其它段落（當然不只這些，比如還有 <a href=\"https://drafts.csswg.org/web-animations/#update-animations-and-send-events\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">update animations and send events</a> 的第 3 步）。</p>\n<p>比較常見的觸發點是 8.1.4.4 的 Calling scripts，它在 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#calling-scripts:perform-a-microtask-checkpoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">clean up after running script 的最後</a>，當呼叫堆疊為空，會施行微任務檢查。</p>\n<p>我沒有很了解 script 在規範中的意義為何，只知道有很多地方都會執行 clean up after running script，最常見的便是<a href=\"https://heycam.github.io/webidl/#invoke-a-callback-function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">調用回呼的 Return 階段的第 2 步</a>，而這就是為什麼在上一節第二個例子中的 <code class=\"language-text\">onClick</code>、<code class=\"language-text\">onAf</code> 會在執行完畢後，馬上施行微任務檢查 。</p>\n<p> 「太瑣碎了吧！我怎麼可能記得住？」在你喊出這句話之前，我要來講一個簡單的判斷方法：只要當前呼叫堆疊為空，微任務檢查便會立即施行；易言之，微任務的執行策略是：<strong>見縫插針、盡可能早</strong>。</p>\n<p>這個判斷方法並沒在規範中明確表述（至少我沒找到），但它應能適用 99.9% 的情境，剩下 0.1% 還有待你分享給我。</p>\n<p>只講一個證據：現代瀏覽器已把 <code class=\"language-text\">Promise.then()</code> 看作是一種微任務（至少在 2015 年前不是如此，詳情可見<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">這篇文章</a>），而在 ECMAScript 規範裡，有一個與微任務相似的概念，叫作 job，而 <a href=\"https://262.ecma-international.org/11.0/#sec-promise-jobs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">Promise.then()</code> 便是一種 job</a>。因此，微任務的執行策略理論上要跟 job 相容。對於 <a href=\"https://262.ecma-international.org/11.0/#sec-jobs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">job 的執行時機</a>，你會發現它跟我前述的判斷方法是一樣的：</p>\n<blockquote>\n<p>在未來的某個時間點，當沒有正在運行的執行上下文，且執行上下文堆疊為空時。</p>\n</blockquote>\n<p>（除了 <code class=\"language-text\">Promise</code>，<a href=\"https://dom.spec.whatwg.org/#queue-a-mutation-observer-compound-microtask\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">MutationObserver</code></a>、<a href=\"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">queueMicrotask</code></a> 也是微任務。有很多文章把 <a href=\"https://html.spec.whatwg.org/multipage/web-messaging.html#window-post-message-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">postMessage</code></a> 也當作微任務，<a href=\"https://html.spec.whatwg.org/multipage/web-messaging.html#window-post-message-steps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">但它其實是宏任務</a>，來自 posted message 任務源 ）</p>\n<h2 id=\"回答開頭的問題\" style=\"position:relative;\"><a href=\"#%E5%9B%9E%E7%AD%94%E9%96%8B%E9%A0%AD%E7%9A%84%E5%95%8F%E9%A1%8C\" aria-label=\"回答開頭的問題 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>回答開頭的問題</h2>\n<p>本文到這裡已經快 7000 字了，原本還想寫事件迴圈可以怎麼應用，但讀者可能已經跑光了（其實是我手痠啦哈哈），加上我還沒有很了解微任務的使用時機，只好作罷。</p>\n<p>在結束之前，看看我開頭提的問題，有什麼是還沒回答的嗎？有！</p>\n<blockquote>\n<p>「幀」是什麼？</p>\n</blockquote>\n<p>幀是組成瀏覽器畫面的基本元素；每個時刻的畫面，都是由一個相同或不同的幀所組成的。想更了解這句話的具體涵義，可查看 <a href=\"https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#frames\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Chrome 開發者工具 Performance 面板的 Frames 斷面圖</a>。</p>\n<p>幀與更新畫面相關，但並<strong>不等同於</strong>更新畫面。幀包括了事件迴圈、佈局（layout）、繪製（paint）等等。一幀就代表一次畫面更新，但不代表只有一輪事件迴圈，因為瀏覽器能根據各種原因跳過更新畫面。</p>\n<p>本文到此（終於）結束，不知道你是否跟我一樣體驗到了事件迴圈的魅力？</p>\n<p>喂？喂？還有人在嗎⋯⋯？</p>\n<h2 id=\"相關資料\" style=\"position:relative;\"><a href=\"#%E7%9B%B8%E9%97%9C%E8%B3%87%E6%96%99\" aria-label=\"相關資料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>相關資料</h2>\n<ul>\n<li><a href=\"https://github.com/fi3ework/blog/issues/29\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">跟着 Event loop 规范理解浏览器中的异步机制</a></li>\n<li><a href=\"https://github.com/aooy/blog/issues/5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">从event loop规范探究javaScript异步及浏览器更新渲染时机</a></li>\n<li><a href=\"https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">深入探究 eventloop 与浏览器渲染的时序问题</a></li>\n<li><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tasks, microtasks, queues and schedules</a></li>\n<li><a href=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Loupe</a>——動畫演示呼叫堆疊、事件循環和任務佇列之間的互動。</li>\n<li>\n<p>規範文件：</p>\n<ul>\n<li><a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">WHATWG HTML Living Standard: Event loops</a></li>\n<li><a href=\"https://dev.w3.org/html5/spec-LC/webappapis.html#event-loops\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">W3C HTML5: Event loops</a></li>\n</ul>\n</li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"/event-loop-in-depth/#js-%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92%E5%8D%BB%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%9A%84%E7%A5%95%E5%AF%86\">JS 單執行緒卻不阻塞的祕密</a></li>\n<li><a href=\"/event-loop-in-depth/#%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">事件迴圈的基本概念</a></li>\n<li><a href=\"/event-loop-in-depth/#%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88%E6%98%AF%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%E7%9A%84%EF%BC%9F\">事件迴圈是怎麼運作的？</a></li>\n<li><a href=\"/event-loop-in-depth/#%E5%BE%9E%E7%AF%84%E4%BE%8B%E4%BA%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88\">從範例了解事件迴圈</a></li>\n<li><a href=\"/event-loop-in-depth/#%E5%BE%AE%E4%BB%BB%E5%8B%99%E7%9A%84%E5%9F%B7%E8%A1%8C%E7%AD%96%E7%95%A5\">微任務的執行策略</a></li>\n<li><a href=\"/event-loop-in-depth/#%E5%9B%9E%E7%AD%94%E9%96%8B%E9%A0%AD%E7%9A%84%E5%95%8F%E9%A1%8C\">回答開頭的問題</a></li>\n<li><a href=\"/event-loop-in-depth/#%E7%9B%B8%E9%97%9C%E8%B3%87%E6%96%99\">相關資料</a></li>\n</ul>","fields":{"slug":"/event-loop-in-depth/"},"frontmatter":{"title":"我知道你懂 Event Loop，但你了解到多深？","description":"從規範文件深入了解瀏覽器的事件迴圈及其相關議題","featuredImage":null,"date":"2021-04-02","tags":["event loop","browser","spec","macrotask","microtask","requestAnimationFrame","requestIdleCallback","timer","js"],"update":"0001-01-01"}}},"pageContext":{"slug":"/event-loop-in-depth/","series":[],"lastmod":"2021-04-02"}},"staticQueryHashes":["2326376460"]}